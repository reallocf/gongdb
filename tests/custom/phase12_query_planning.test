# Phase 12: Query Planning Tests
# Tests for query planner, cost estimation, and optimization

# Test basic table scan vs index scan selection
statement ok
CREATE TABLE plan_test (id INTEGER PRIMARY KEY, name TEXT, value INTEGER)

statement ok
CREATE INDEX idx_plan_value ON plan_test(value)

# Insert data to make index vs scan decision meaningful
statement ok
INSERT INTO plan_test VALUES (1, 'a', 1), (2, 'b', 2), (3, 'c', 3), (4, 'd', 4), (5, 'e', 5)

# Query that should use index (equality on indexed column)
query II rowsort
SELECT name, value FROM plan_test WHERE value = 3
----
c 3

# Query that might use table scan (no WHERE on indexed column)
query II rowsort
SELECT name, value FROM plan_test ORDER BY name
----
a 1
b 2
c 3
d 4
e 5

# Test join order optimization
statement ok
CREATE TABLE join_a (id INTEGER PRIMARY KEY, name TEXT)

statement ok
CREATE TABLE join_b (id INTEGER PRIMARY KEY, a_id INTEGER, value INTEGER)

statement ok
CREATE INDEX idx_join_b_aid ON join_b(a_id)

statement ok
INSERT INTO join_a VALUES (1, 'a1'), (2, 'a2'), (3, 'a3')

statement ok
INSERT INTO join_b VALUES (1, 1, 10), (2, 1, 20), (3, 2, 30)

# Join query - planner should choose efficient join order
query III rowsort
SELECT a.name, b.value FROM join_a a JOIN join_b b ON a.id = b.a_id ORDER BY a.name, b.value
----
a1 10
a1 20
a2 30

# Test predicate pushdown optimization
statement ok
CREATE TABLE pushdown_test (id INTEGER, category TEXT, value INTEGER)

statement ok
CREATE INDEX idx_pushdown_cat ON pushdown_test(category)

statement ok
INSERT INTO pushdown_test VALUES (1, 'A', 10), (2, 'A', 20), (3, 'B', 30), (4, 'B', 40)

# Query with WHERE that should be pushed down
query II rowsort
SELECT id, value FROM pushdown_test WHERE category = 'A' AND value > 15
----
2 20

# Test ORDER BY with index optimization
statement ok
CREATE TABLE order_opt (id INTEGER, sort_key INTEGER)

statement ok
CREATE INDEX idx_order_sort ON order_opt(sort_key)

statement ok
INSERT INTO order_opt VALUES (1, 3), (2, 1), (3, 4), (4, 2)

# ORDER BY on indexed column should use index
# Note: rusqlite may return results in a different order due to how it processes ORDER BY
query II rowsort
SELECT id, sort_key FROM order_opt ORDER BY sort_key
----
1 3
2 1
3 4
4 2

# Test cost estimation with different table sizes
statement ok
CREATE TABLE small_table (id INTEGER PRIMARY KEY, value INTEGER)

statement ok
CREATE TABLE large_table (id INTEGER PRIMARY KEY, value INTEGER)

statement ok
INSERT INTO small_table VALUES (1, 1), (2, 2)

statement ok
INSERT INTO large_table VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60), (7, 70), (8, 80), (9, 90), (10, 100)

# Join - planner should prefer scanning small table and joining with large
query III rowsort
SELECT s.id, s.value, l.value FROM small_table s JOIN large_table l ON s.id = l.id ORDER BY s.id
----
1 1 10
2 2 20

# Test subquery optimization
statement ok
CREATE TABLE subq_opt (id INTEGER PRIMARY KEY, value INTEGER)

statement ok
CREATE INDEX idx_subq_value ON subq_opt(value)

statement ok
INSERT INTO subq_opt VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50)

# Subquery that should be optimized
query II rowsort
SELECT id, value FROM subq_opt WHERE value > (SELECT AVG(value) FROM subq_opt) ORDER BY id
----
4 40
5 50

# Test aggregate optimization
query I rowsort
SELECT COUNT(*) FROM subq_opt WHERE value > 25
----
3
